/*
 * The Fungu Scripting Engine
 *
 * (C) Copyright 2008 Graham Daws
 * (C) Copyright 2005 Christopher Diggins
 * (C) Copyright 2005 Pablo Aguilar
 * (C) Copyright 2001 Kevlin Henney
 *
 *  Boost Software License - Version 1.0 - August 17th, 2003
 *
 *  Permission is hereby granted, free of charge, to any person or organization
 *  obtaining a copy of the software and accompanying documentation covered by
 *  this license (the "Software") to use, reproduce, display, distribute,
 *  execute, and transmit the Software, and to prepare derivative works of the
 *  Software, and to permit third-parties to whom the Software is furnished to
 *  do so, all subject to the following:
 *
 *  The copyright notices in the Software and this entire statement, including
 *  the above license grant, this restriction and the following disclaimer,
 *  must be included in all copies of the Software, in whole or in part, and
 *  all derivative works of the Software, unless such copies or derivative
 *  works are solely in the form of machine-executable object code generated by
 *  a source language processor.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

namespace fungu{
namespace script{

bad_any_cast::bad_any_cast(const std::type_info& src, const std::type_info& dest)
:from(src.name()),
 to(dest.name())
{
    
}

const char* bad_any_cast::what()
{
    return "bad cast";
}

any::any()
{
    table = any_detail::get_table<any_detail::empty>::get();
    object = NULL;
}

any::any(const any & x)
{
    table = any_detail::get_table<any_detail::empty>::get();
    assign(x);
}

any::~any()
{
    table->static_delete(&object);
}

any & any::assign(const any & x)
{
    // are we copying between the same type?
    if (table == x.table)
    {
        // if so, we can avoid reallocation
        table->move(&x.object, &object);
    }
    else
    {
        reset();
        x.table->clone(&x.object, &object);
        table = x.table;
    }
    
    return *this;
}

any& any::operator=(const any & x)
{
    return assign(x);
}

any& any::swap(any& x)
{
    std::swap(table, x.table);
    std::swap(object, x.object);
    return *this;
}

const std::type_info & any::get_type()const
{
    return table->get_type();
}

type_id any::get_type_id()const
{
    return table->get_type_id();
}

const_string any::to_string()const
{
    return table->to_string(&object);
}

#ifdef FUNGU_WITH_LUA
void any::push_value(lua_State * L)const
{
    table->lua_push_value(L, &object);
}
#endif

bool any::empty()const
{
    return table == any_detail::get_table<any_detail::empty>::get();
}

void any::reset()
{
    if (empty()) return;
    table->static_delete(&object);
    table = any_detail::get_table<any_detail::empty>::get();
    object = NULL;
}

any any::null_value()
{
    return any();
}

bool any_is_string(const any & var)
{
    return var.get_type() == typeid(const_string);
}

} //namespace script
} //namespace fungu
